---
title: "Development of Package qzwslrm"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Development of Package qzwslrm}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, eval=TRUE}
library(qzwslrm)
```

# Background
As described in [Legarra and Reverter (2018)](https://link.springer.com/article/10.1186/s12711-018-0426-6), validation of predicted breeding values is becoming more and more important. Their work uses a cross-validation based approach using results of successive genetic evaluations. These results consist of $\hat{u}_p$ and $\hat{u}_w$ which are vectors of the same length and contain predicted breeding values based on "partial" ($p$) and "whole" ($w$) data, respectively. 


# Cross-Validation Statistics
The following statistics are computed based on the input $\hat{u}_p$ and $\hat{u}_w$

* bias: $\overline{\hat{u}_p} - \overline{\hat{u}_w}$
* regression of whole on partial: $b_{w,p} = \frac{cov(\hat{u}_w,\hat{u}_p)}{var(\hat{u}_p)}$
* correlation between whole and partial: $r_{w,p} = \frac{cov(\hat{u}_w,\hat{u}_p)}{\sqrt{var(\hat{u}_p)var(\hat{u}_w)}}$
* regression of partial on whole: $b_{p,w} = \frac{cov(\hat{u}_w,\hat{u}_p)}{var(\hat{u}_w)}$


# Example Data
As shown in https://fbzwsqualitasag.github.io/qzwslrm/articles/qzwslrm_ebv_mix99.html, example data are prepared to run the most basic validation statistics. The example data consists of two results files from MiX99 containing predicted breeding values. The first result file contains EBV predicted based on a complete dataset. 

```{r}
(s_ebv_path_whole <- qzwslrm_example_solani("whole"))
```

The second result file contains EBV predicted for the same animals but based on a partial dataset. For our example, the phenotypic observations of all animals from the latest generation were set to missing (NA).

```{r}
(s_ebv_path_partial <- qzwslrm_example_solani("partial"))
```

These files can be read using the function `read_solani()`

```{r}
(tbl_solani_whole <- readr_solani(ps_path = s_ebv_path_whole))
```

The same can be done with the partial data 

```{r}
(tbl_solani_partial <- readr_solani(ps_path = s_ebv_path_partial))
```

# Validation
For the validation only the EBV vectors from the full and the partial data are required. Hence the validation function only needs the two vectors as input.

```{r}
(l_val_result <- val_ebv_lrm(pvec_ebv_partial = tbl_solani_partial$ebv, 
                             pvec_ebv_whole = tbl_solani_whole$ebv))
```


